From e58e6b25c82cc2f76f08b291e14f4e81f4ae1364 Mon Sep 17 00:00:00 2001
From: Guy Harris <guy@alum.mit.edu>
Date: Wed, 5 Nov 2014 11:18:51 -0800
Subject: [PATCH 3/3] More descriptive name for bpf_filter1().

Call it bpf_filter_with_aux_data(), to better indicate what it does.

Also expand some comments and clean up white space a bit.

(cherry picked from 20119d41be224cf9ea821155ad0b267f7e40f234)

Conflicts:
        pcap-linux.c
---
 bpf/net/bpf_filter.c | 7 +++++--
 pcap-linux.c         | 7 +++----
 pcap/bpf.h           | 7 ++++++-
 3 files changed, 14 insertions(+), 7 deletions(-)

diff --git a/bpf/net/bpf_filter.c b/bpf/net/bpf_filter.c
index 3409a9b..307f980 100644
--- a/bpf/net/bpf_filter.c
+++ b/bpf/net/bpf_filter.c
@@ -215,11 +215,14 @@ enum {
  * Execute the filter program starting at pc on the packet p
  * wirelen is the length of the original packet
  * buflen is the amount of data present
+ * aux_data is auxiliary data, currently used only when interpreting
+ * filters intended for the Linux kernel in cases where the kernel
+ * rejects the filter; it contains VLAN tag information
  * For the kernel, p is assumed to be a pointer to an mbuf if buflen is 0,
  * in all other cases, p is a pointer to a buffer and buflen is its size.
  */
 u_int
-bpf_filter1(pc, p, wirelen, buflen, aux_data)
+bpf_filter_with_aux_data(pc, p, wirelen, buflen, aux_data)
 	register const struct bpf_insn *pc;
 	register const u_char *p;
 	u_int wirelen;
@@ -579,7 +582,7 @@ bpf_filter(pc, p, wirelen, buflen)
 	u_int wirelen;
 	register u_int buflen;
 {
-	return bpf_filter1(pc, p, wirelen, buflen, NULL);
+	return bpf_filter_with_aux_data(pc, p, wirelen, buflen, NULL);
 }
 
 
diff --git a/pcap-linux.c b/pcap-linux.c
index 68e6d05..a370858 100644
--- a/pcap-linux.c
+++ b/pcap-linux.c
@@ -1708,9 +1708,8 @@ pcap_read_packet(pcap_t *handle, pcap_handler callback, u_char *userdata)
 
 	/* Run the packet filter if not using kernel filter */
 	if (handlep->filter_in_userland && handle->fcode.bf_insns) {
-		if (bpf_filter1(handle->fcode.bf_insns, bp,
-		                packet_len, caplen, &aux_data) == 0)
-		{
+		if (bpf_filter_with_aux_data(handle->fcode.bf_insns, bp,
+		    packet_len, caplen, &aux_data) == 0) {
 			/* rejected by filter */
 			return 0;
 		}
@@ -4282,7 +4281,7 @@ static int pcap_handle_packet_mmap(
                 aux_data.vlan_tag = tp_vlan_tci & 0x0fff;
                 aux_data.vlan_tag_present = tp_vlan_tci_valid;
 
-                if (bpf_filter1(handle->fcode.bf_insns, bp, tp_len, tp_snaplen, &aux_data) == 0)
+                if (bpf_filter_with_aux_data(handle->fcode.bf_insns, bp, tp_len, tp_snaplen, &aux_data) == 0)
                         return 0;
         }
 
diff --git a/pcap/bpf.h b/pcap/bpf.h
index 495f326..29efd7e 100644
--- a/pcap/bpf.h
+++ b/pcap/bpf.h
@@ -1320,6 +1320,11 @@ struct bpf_insn {
 	bpf_u_int32 k;
 };
 
+/*
+ * Auxiliary data, for use when interpreting a filter intended for the
+ * Linux kernel when the kernel rejects the filter (requiring us to
+ * run it in userland).  It contains VLAN tag information.
+ */
 struct bpf_aux_data {
         uint16_t vlan_tag_present;
         uint16_t vlan_tag;
@@ -1334,7 +1339,7 @@ struct bpf_aux_data {
 #if __STDC__ || defined(__cplusplus)
 extern int bpf_validate(const struct bpf_insn *, int);
 extern u_int bpf_filter(const struct bpf_insn *, const u_char *, u_int, u_int);
-extern u_int bpf_filter1(const struct bpf_insn *, const u_char *, u_int, u_int, const struct bpf_aux_data *);        
+extern u_int bpf_filter_with_aux_data(const struct bpf_insn *, const u_char *, u_int, u_int, const struct bpf_aux_data *);        
 #else
 extern int bpf_validate();
 extern u_int bpf_filter();
-- 
2.4.3

